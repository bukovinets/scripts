#!/bin/bash

# ==========================================
# CONFIGURATION
# ==========================================
# How many minutes BEFORE the backup schedule should we update the job?
PADDING_MINUTES=10

# File Paths
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
UPDATER_SCRIPT="${SCRIPT_DIR}/updater.sh"
STATE_FILE="${SCRIPT_DIR}/job_state.txt"
LOG_FILE="${SCRIPT_DIR}/automation.log"

# Markers
CRON_START="# --- AUTOGENERATED BACKUP UPDATER START ---"
CRON_END="# --- AUTOGENERATED BACKUP UPDATER END ---"

# ==========================================
# FUNCTIONS
# ==========================================

log_msg() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') [MANAGER] $1" >> "$LOG_FILE"
}

send_notification() {
    local subject="$1"
    local message="$2"
    local severity="${3:-error}" # info, error, warning

    # Log it first
    log_msg "NOTIFICATION: $subject - $message"

    # Method 1: Try Modern Proxmox Notification System (PVE 8.1+)
    if command -v proxmox-notify-client >/dev/null 2>&1; then
        echo "$message" | proxmox-notify-client --severity "$severity" --type custom --subject "$subject"
    
    # Method 2: Fallback to standard mail (Legacy)
    else
        echo "$message" | mail -s "Proxmox Backup Script: $subject" root
    fi
}

# ==========================================
# PYTHON PARSER (Embedded)
# ==========================================
# This python script reads JSON from STDIN and outputs:
# JOB_ID | CRON_MIN | CRON_HOUR | ORIGINAL_SCHEDULE
# It handles the time calculation to ensure safety.
read -r -d '' PYTHON_PARSER << EOM
import sys, json, datetime

padding = int(sys.argv[1])

try:
    data = json.load(sys.stdin)
    if not isinstance(data, list): data = [data] # Handle single object case

    valid_jobs = 0

    for job in data:
        # Filter for vzdump jobs only
        if job.get('type') != 'vzdump': continue
        if job.get('enabled', 1) == 0: continue # Skip disabled jobs
        
        jid = job.get('id')
        schedule = job.get('schedule')

        if not jid or not schedule: continue

        # Parse Schedule (HH:MM)
        try:
            # We assume format HH:MM. If complex calendar event, this simple logic skips it safely.
            t = datetime.datetime.strptime(schedule, "%H:%M")
            
            # Subtract padding
            new_time = t - datetime.timedelta(minutes=padding)
            
            print(f"{jid}|{new_time.minute}|{new_time.hour}|{schedule}")
            valid_jobs += 1
        except ValueError:
            # Schedule format might be complex (e.g. 'sat 12:00'), skip for now or handle differently
            continue

    if valid_jobs == 0:
        sys.exit(2) # Exit code 2 means JSON parsed but no valid scheduled jobs found

except json.JSONDecodeError:
    sys.exit(1) # Exit code 1 means JSON failed
except Exception as e:
    sys.exit(1)
EOM

# ==========================================
# MAIN LOGIC
# ==========================================

log_msg "Starting execution..."

# 1. Fetch JSON
raw_jobs=$(pvesh get /cluster/backup --output-format json)
if [ -z "$raw_jobs" ]; then
    log_msg "ERROR: Failed to retrieve backup jobs from API (Empty result)."
    send_notification "Backup Automation Failed" "API returned no data."
    exit 1
fi

# 2. Parse and Calculate using Python
# We pass the JSON to python and get clean pipe-delimited lines back
parsed_output=$(echo "$raw_jobs" | python3 -c "$PYTHON_PARSER" "$PADDING_MINUTES")
exit_code=$?

if [ $exit_code -ne 0 ]; then
    if [ $exit_code -eq 2 ]; then
        log_msg "WARNING: No valid scheduled backup jobs found (or schedules were complex/unparseable)."
        # We do not exit here, we might need to clear the crontab if jobs were deleted.
    else
        log_msg "ERROR: Failed to parse backup schedule JSON."
        log_msg "DEBUG RAW: $(echo "$raw_jobs" | cut -c 1-100)..." # Log first 100 chars
        send_notification "Backup Automation Failed" "Script failed to parse job schedules. Check logs."
        exit 1
    fi
fi

# 3. Build new State and Cron Block
current_state=""
new_cron_block=""
job_count=0

while IFS='|' read -r jid min hour schedule; do
    if [ -n "$jid" ]; then
        # Build State: ID matches Schedule
        current_state+="${jid}=${schedule}"$'\n'
        
        # Build Cron: M H * * * script job_id
        new_cron_block+="${min} ${hour} * * * ${UPDATER_SCRIPT} ${jid}"$'\n'
        job_count=$((job_count + 1))
    fi
done <<< "$parsed_output"

log_msg "Parsed $job_count valid jobs."

# 4. Compare with State File
has_changes=false
if [ -f "$STATE_FILE" ]; then
    last_state=$(cat "$STATE_FILE")
    if [ "$current_state" != "$last_state" ]; then
        has_changes=true
        log_msg "Changes detected in job configuration."
    fi
else
    has_changes=true
    log_msg "State file missing. Initializing."
fi

# 5. Apply Updates (Only if changed)
# Safety Check: If job_count is 0, we only clear crontab if we previously had jobs.
if [ "$has_changes" = true ]; then
    
    # Save State
    echo -n "$current_state" > "$STATE_FILE"
    
    # Read current crontab, excluding our block
    current_cron=$(crontab -l 2>/dev/null | sed "/$CRON_START/,/$CRON_END/d")
    
    # Construct new crontab
    if [ -n "$new_cron_block" ]; then
        final_cron="${current_cron}
${CRON_START}
${new_cron_block}
${CRON_END}"
    else
        final_cron="${current_cron}" # Just remove the block if no jobs
    fi
    
    # Apply
    echo "$final_cron" | sed '/^$/d' | crontab -
    
    if [ $? -eq 0 ]; then
        log_msg "Crontab updated successfully."
        # Optional: Notify on successful change so you know it's working
        # send_notification "Backup Automation Updated" "Scheduler updated for $job_count jobs." "info"
    else
        log_msg "ERROR: Failed to write to crontab."
        send_notification "Backup Automation Failed" "Could not write to crontab."
        exit 1
    fi
else
    log_msg "No changes required."
fi