#!/bin/bash

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
UPDATER_SCRIPT="${SCRIPT_DIR}/updater.sh"
STATE_FILE="${SCRIPT_DIR}/job_state.txt"
CRON_START="# --- AUTOGENERATED BACKUP UPDATER START ---"
CRON_END="# --- AUTOGENERATED BACKUP UPDATER END ---"
CONTEXT="[MANAGER]"

if [ -f "${SCRIPT_DIR}/common.sh" ]; then
    . "${SCRIPT_DIR}/common.sh"
else
    echo "CRITICAL: common.sh missing" && exit 1
fi

log_section "$CONTEXT" "Starting Scheduler execution..."

# ==========================================
# PYTHON PARSER
# ==========================================
read -r -d '' PYTHON_PARSER << EOM
import sys, json, datetime

padding = int(sys.argv[1])
try:
    data = json.load(sys.stdin)
    if not isinstance(data, list): data = [data]

    for job in data:
        if job.get('type') != 'vzdump': continue
        if job.get('enabled', 1) == 0: continue 

        jid = job.get('id')
        schedule = job.get('schedule')

        if not jid or not schedule: continue

        try:
            t = datetime.datetime.strptime(schedule, "%H:%M")
            trigger_time = t - datetime.timedelta(minutes=padding)
            cron_entry = f"{trigger_time.minute} {trigger_time.hour} * * * {sys.argv[2]} {jid}"
            print(f"VALID|{jid}|{trigger_time.minute}|{trigger_time.hour}|{schedule}|{cron_entry}")
        except ValueError:
            print(f"SKIP|{jid}|{schedule}")

except Exception as e:
    sys.exit(1)
EOM

# ==========================================
# EXECUTION
# ==========================================

log_msg "INFO" "$CONTEXT" "Fetching backup jobs from Proxmox API..."
raw_jobs=$(pvesh get /cluster/backup --output-format json)

if [ -z "$raw_jobs" ]; then
    log_msg "ERROR" "$CONTEXT" "API returned empty result."
    send_notification "Manager Failed" "ERROR" "$CONTEXT"
    exit 1
fi

parsed_output=$(echo "$raw_jobs" | python3 -c "$PYTHON_PARSER" "$PADDING_MINUTES" "$UPDATER_SCRIPT")
if [ $? -ne 0 ]; then
    log_msg "ERROR" "$CONTEXT" "Python parser crashed."
    send_notification "Manager Parser Crashed" "ERROR" "$CONTEXT"
    exit 1
fi

current_state=""
new_cron_block=""
valid_count=0

while IFS='|' read -r type col1 col2 col3 col4 col5; do
    if [ "$type" == "SKIP" ]; then
        log_msg "WARNING" "$CONTEXT" "Skipping complex/invalid schedule for job $col1 ($col2)"
    elif [ "$type" == "VALID" ]; then
        jid=$col1
        min=$col2
        hour=$col3
        orig_sched=$col4
        cron_line=$col5
        
        log_msg "INFO" "$CONTEXT" "Found Job: $jid with Schedule: $orig_sched"
        log_msg "INFO" "$CONTEXT" "Scheduled Updater for: $hour:$min (Cron: $cron_line)"
        
        current_state+="${jid}=${orig_sched}"$'\n'
        new_cron_block+="${cron_line}"$'\n'
        valid_count=$((valid_count + 1))
    fi
done <<< "$parsed_output"

log_msg "INFO" "$CONTEXT" "Processed $valid_count valid jobs."

has_changes=false
if [ -f "$STATE_FILE" ]; then
    last_state=$(cat "$STATE_FILE")
    if [ "$current_state" != "$last_state" ]; then
        has_changes=true
        log_msg "INFO" "$CONTEXT" "Changes detected in configuration."
    else
        log_msg "INFO" "$CONTEXT" "No changes needed."
    fi
else
    has_changes=true
    log_msg "INFO" "$CONTEXT" "State file missing. Initializing."
fi

if [ "$has_changes" = true ]; then
    echo -n "$current_state" > "$STATE_FILE"
    
    current_cron=$(crontab -l 2>/dev/null | sed "/$CRON_START/,/$CRON_END/d")
    final_cron="${current_cron}
${CRON_START}
${new_cron_block}
${CRON_END}"

    echo "$final_cron" | sed '/^$/d' | crontab -
    
    if [ $? -eq 0 ]; then
        log_msg "INFO" "$CONTEXT" "Crontab updated successfully."
        send_notification "Manager Updated Crontab" "SUCCESS" "$CONTEXT"
    else
        log_msg "ERROR" "$CONTEXT" "Failed to write crontab."
        send_notification "Manager Crontab Write Failed" "ERROR" "$CONTEXT"
    fi
else
    send_notification "Manager Execution (No Change)" "SUCCESS" "$CONTEXT"
fi