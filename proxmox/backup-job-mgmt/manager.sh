#!/bin/bash

# Define Context for Logging BEFORE sourcing common.sh
LOG_CONTEXT="[MANAGER]"
COMMON_LIB="/root/backup-mgmt/common.sh"
STATE_FILE="/root/backup-mgmt/job_state.txt"
UPDATER_SCRIPT="/root/backup-mgmt/updater.sh"

# Source the common library
if [ -f "$COMMON_LIB" ]; then
    source "$COMMON_LIB"
else
    echo "ERROR: Could not find $COMMON_LIB"
    exit 1
fi

log "INFO" "Starting execution..."

# Check dependencies
if ! command -v pvesh &> /dev/null; then
    log "ERROR" "pvesh command not found."
    send_notification "error"
    exit 1
fi

# 1. Fetch all backup jobs
log "INFO" "Fetching backup jobs from Proxmox API..."
JOBS_JSON=$(pvesh get /cluster/backup --output-format json)

if [ $? -ne 0 ] || [ -z "$JOBS_JSON" ]; then
    log "ERROR" "Failed to retrieve backup jobs from API."
    send_notification "error"
    exit 1
fi

# 2. Parse jobs (ID and Schedule)
PARSED_JOBS=$(echo "$JOBS_JSON" | python3 -c "import sys, json; [print(f\"{x['id']} {x['schedule']}\") for x in json.load(sys.stdin) if 'id' in x and 'schedule' in x]")

if [ -z "$PARSED_JOBS" ]; then
    log "WARN" "No backup jobs found with schedules."
    send_notification "success"
    exit 0
fi

# 3. Detect changes
NEW_STATE=""
CRONTAB_ENTRIES=""
CHANGES_DETECTED=false
JOB_COUNT=0

# Read current state
if [ -f "$STATE_FILE" ]; then
    CURRENT_STATE=$(cat "$STATE_FILE")
else
    CURRENT_STATE=""
fi

log "INFO" "Processing jobs..."

while read -r line; do
    JOB_ID=$(echo "$line" | awk '{print $1}')
    SCHEDULE=$(echo "$line" | awk '{print $2}')
    
    if [[ "$JOB_ID" != backup* ]]; then continue; fi

    log "INFO" "Found Job: $JOB_ID with Schedule: $SCHEDULE"

    # Convert Schedule (HH:MM) -> Updater Cron (HH:MM - 10 mins)
    HOUR=${SCHEDULE%:*}
    MINUTE=${SCHEDULE#*:}
    MINUTE_NUM=$((10#$MINUTE))
    HOUR_NUM=$((10#$HOUR))

    if [ "$MINUTE_NUM" -ge 10 ]; then
        UPDATER_MIN=$((MINUTE_NUM - 10))
        UPDATER_HOUR=$HOUR_NUM
    else
        UPDATER_MIN=$((MINUTE_NUM + 50))
        UPDATER_HOUR=$((HOUR_NUM - 1))
        if [ "$UPDATER_HOUR" -lt 0 ]; then UPDATER_HOUR=23; fi
    fi

    NEW_STATE+="$JOB_ID=$SCHEDULE"$'\n'
    CRON_CMD="$UPDATER_SCRIPT $JOB_ID"
    CRON_ENTRY="$UPDATER_MIN $UPDATER_HOUR * * * $CRON_CMD"
    CRONTAB_ENTRIES+="$CRON_ENTRY"$'\n'
    
    log "INFO" "Scheduled Updater for: $UPDATER_HOUR:$UPDATER_MIN (Cron: $CRON_ENTRY)"
    ((JOB_COUNT++))

done <<< "$PARSED_JOBS"

log "INFO" "Processed $JOB_COUNT valid jobs."

# Check for state changes
SORTED_OLD=$(echo "$CURRENT_STATE" | sort)
SORTED_NEW=$(echo -n "$NEW_STATE" | sort)

if [ "$SORTED_OLD" != "$SORTED_NEW" ]; then
    CHANGES_DETECTED=true
    log "INFO" "Configuration changes detected."
else
    log "INFO" "No configuration changes detected."
fi

# 4. Update Crontab if needed
CURRENT_CRONTAB=$(crontab -l 2>/dev/null)
if [[ "$CHANGES_DETECTED" == "true" ]] || ! echo "$CURRENT_CRONTAB" | grep -q "AUTOGENERATED BACKUP UPDATER START"; then
    log "INFO" "Updating Crontab..."

    CLEAN_CRONTAB=$(echo "$CURRENT_CRONTAB" | sed '/--- AUTOGENERATED BACKUP UPDATER START ---/,/--- AUTOGENERATED BACKUP UPDATER END ---/d')

    NEW_CRONTAB="$CLEAN_CRONTAB"
    if [ ! -z "$CLEAN_CRONTAB" ]; then NEW_CRONTAB+=$'\n'; fi
    NEW_CRONTAB+="# --- AUTOGENERATED BACKUP UPDATER START ---"$'\n'
    NEW_CRONTAB+="$CRONTAB_ENTRIES"
    NEW_CRONTAB+="# --- AUTOGENERATED BACKUP UPDATER END ---"$'\n'

    echo "$NEW_CRONTAB" | crontab -
    
    if [ $? -eq 0 ]; then
        log "INFO" "Crontab updated successfully."
        echo -n "$NEW_STATE" > "$STATE_FILE"
    else
        log "ERROR" "Failed to update crontab."
        send_notification "error"
        exit 1
    fi
fi

log "INFO" "Manager run completed successfully."
send_notification "success"