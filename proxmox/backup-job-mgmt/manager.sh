#!/bin/bash

# ==========================================
# CONFIGURATION
# ==========================================
# How many minutes BEFORE the backup schedule should we update the job?
# Change this on different nodes to avoid collision (e.g., 10 on Node A, 15 on Node B)
PADDING_MINUTES=10

# File Paths (Relative to this script)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
UPDATER_SCRIPT="${SCRIPT_DIR}/updater.sh"
STATE_FILE="${SCRIPT_DIR}/job_state.txt"
LOG_FILE="${SCRIPT_DIR}/automation.log"

# Marker for Crontab (Do not change once set)
CRON_START="# --- AUTOGENERATED BACKUP UPDATER START ---"
CRON_END="# --- AUTOGENERATED BACKUP UPDATER END ---"

# ==========================================
# FUNCTIONS
# ==========================================
log_msg() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') [MANAGER] $1" >> "$LOG_FILE"
}

# Function to subtract minutes from HH:MM time
calc_cron_time() {
    local schedule="$1"
    # Extract HH and MM (Assume format is HH:MM or similar)
    # This regex looks for the last occurrence of HH:MM in the string
    if [[ "$schedule" =~ ([0-9]{1,2}):([0-9]{2}) ]]; then
        local hour="${BASH_REMATCH[1]}"
        local min="${BASH_REMATCH[2]}"
        
        # Convert to minutes from midnight
        local total_min=$(( 10#$hour * 60 + 10#$min ))
        
        # Subtract padding
        local new_total=$(( total_min - PADDING_MINUTES ))
        
        # Handle day rollover (negative time)
        if [ "$new_total" -lt 0 ]; then
            new_total=$(( new_total + 1440 ))
        fi
        
        # Convert back to HH MM
        local new_hour=$(( new_total / 60 ))
        local new_min=$(( new_total % 60 ))
        
        echo "$new_min $new_hour"
    else
        echo "ERROR"
    fi
}

# ==========================================
# MAIN LOGIC
# ==========================================

# 1. Fetch all Backup Jobs (vzdump) from Proxmox API
# We verify they are enabled and strictly look for backup jobs.
raw_jobs=$(pvesh get /cluster/backup --output-format json)

# Prepare to build the new state and cron lines
current_state=""
new_cron_block=""
has_changes=false
jobs_found=0

log_msg "Scanning for backup jobs..."

# Loop through jobs (parsing JSON with basic grep/sed to avoid 'jq' dependency if missing)
# IDs look like "backup-1234", Schedules look like "22:00"
while read -r line; do
    job_id=$(echo "$line" | awk '{print $1}')
    schedule=$(echo "$line" | awk '{$1=""; print $0}' | xargs) # Everything else is schedule

    # Skip if schedule is missing
    if [ -z "$schedule" ] || [ "$schedule" == "null" ]; then continue; fi

    jobs_found=$((jobs_found + 1))
    
    # Calculate Cron Time
    cron_time=$(calc_cron_time "$schedule")
    
    if [ "$cron_time" == "ERROR" ]; then
        log_msg "WARNING: Could not parse schedule '$schedule' for job $job_id. Skipping."
        continue
    fi

    # Build State Entry: "ID|SCHEDULE"
    current_state+="${job_id}|${schedule}"$'\n'

    # Build Cron Line: "MM HH * * * /path/to/updater.sh JOB_ID"
    new_cron_block+="${cron_time} * * * ${UPDATER_SCRIPT} ${job_id}"$'\n'

done < <(echo "$raw_jobs" | grep "backup-" | awk -F '"' '{for(i=1;i<=NF;i++) if($i=="id") print $(i+2), $(i+6)}') 
# Note: The weird grep/awk above is a robust way to parse simple JSON without 'jq'.
# It extracts the 'id' value and the 'schedule' value.

# 2. Compare with Previous State
if [ -f "$STATE_FILE" ]; then
    last_state=$(cat "$STATE_FILE")
    if [ "$current_state" != "$last_state" ]; then
        has_changes=true
        log_msg "Change detected in backup schedules or job IDs."
    else
        log_msg "No changes detected. Jobs match state file."
    fi
else
    has_changes=true
    log_msg "State file missing. Initializing first run."
fi

# 3. Update System if Changes Detected
if [ "$has_changes" = true ] && [ "$jobs_found" -gt 0 ]; then
    
    # Save new state
    echo -n "$current_state" > "$STATE_FILE"
    
    # Read current crontab, excluding our managed block
    current_cron=$(crontab -l 2>/dev/null | sed "/$CRON_START/,/$CRON_END/d")
    
    # Combine old cron + marker + new block + marker
    final_cron="${current_cron}
${CRON_START}
${new_cron_block}
${CRON_END}"
    
    # Apply new crontab (Removing empty lines to be clean)
    echo "$final_cron" | sed '/^$/d' | crontab -
    
    log_msg "Crontab updated successfully with $jobs_found jobs."
elif [ "$jobs_found" -eq 0 ]; then
    log_msg "No backup jobs found in Proxmox configuration."
fi